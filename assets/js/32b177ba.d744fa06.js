"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[26],{4042:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>k,contentTitle:()=>P,default:()=>D,frontMatter:()=>_,metadata:()=>O,toc:()=>N});var n=t(4848),l=t(8453),r=t(6540),o=t(4164),s=t(3104),a=t(6347),c=t(205),d=t(7485),h=t(1682),u=t(679);function x(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:i}=e;return!!i&&"object"==typeof i&&"value"in i}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:i,children:t}=e;return(0,r.useMemo)((()=>{const e=i??function(e){return x(e).map((e=>{let{props:{value:i,label:t,attributes:n,default:l}}=e;return{value:i,label:t,attributes:n,default:l}}))}(t);return function(e){const i=(0,h.XI)(e,((e,i)=>e.value===i.value));if(i.length>0)throw new Error(`Docusaurus error: Duplicate values "${i.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[i,t])}function j(e){let{value:i,tabValues:t}=e;return t.some((e=>e.value===i))}function f(e){let{queryString:i=!1,groupId:t}=e;const n=(0,a.W6)(),l=function(e){let{queryString:i=!1,groupId:t}=e;if("string"==typeof i)return i;if(!1===i)return null;if(!0===i&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:i,groupId:t});return[(0,d.aZ)(l),(0,r.useCallback)((e=>{if(!l)return;const i=new URLSearchParams(n.location.search);i.set(l,e),n.replace({...n.location,search:i.toString()})}),[l,n])]}function v(e){const{defaultValue:i,queryString:t=!1,groupId:n}=e,l=p(e),[o,s]=(0,r.useState)((()=>function(e){let{defaultValue:i,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(i){if(!j({value:i,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${i}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return i}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:i,tabValues:l}))),[a,d]=f({queryString:t,groupId:n}),[h,x]=function(e){let{groupId:i}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(i),[n,l]=(0,u.Dv)(t);return[n,(0,r.useCallback)((e=>{t&&l.set(e)}),[t,l])]}({groupId:n}),v=(()=>{const e=a??h;return j({value:e,tabValues:l})?e:null})();(0,c.A)((()=>{v&&s(v)}),[v]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!j({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);s(e),d(e),x(e)}),[d,x,l]),tabValues:l}}var m=t(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:i,block:t,selectedValue:l,selectValue:r,tabValues:a}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.a_)(),h=e=>{const i=e.currentTarget,t=c.indexOf(i),n=a[t].value;n!==l&&(d(i),r(n))},u=e=>{let i=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;i=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;i=c[t]??c[c.length-1];break}}i?.focus()};return(0,n.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":t},i),children:a.map((e=>{let{value:i,label:t,attributes:r}=e;return(0,n.jsx)("li",{role:"tab",tabIndex:l===i?0:-1,"aria-selected":l===i,ref:e=>c.push(e),onKeyDown:u,onClick:h,...r,className:(0,o.A)("tabs__item",g.tabItem,r?.className,{"tabs__item--active":l===i}),children:t??i},i)}))})}function w(e){let{lazy:i,children:t,selectedValue:l}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(i){const e=s.find((e=>e.props.value===l));return e?(0,r.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,n.jsx)("div",{className:"margin-top--md",children:s.map(((e,i)=>(0,r.cloneElement)(e,{key:i,hidden:e.props.value!==l})))})}function S(e){const i=v(e);return(0,n.jsxs)("div",{className:(0,o.A)("tabs-container",g.tabList),children:[(0,n.jsx)(b,{...i,...e}),(0,n.jsx)(w,{...i,...e})]})}function y(e){const i=(0,m.A)();return(0,n.jsx)(S,{...e,children:x(e.children)},String(i))}const T={tabItem:"tabItem_Ymn6"};function A(e){let{children:i,hidden:t,className:l}=e;return(0,n.jsx)("div",{role:"tabpanel",className:(0,o.A)(T.tabItem,l),hidden:t,children:i})}const _={sidebar_position:4,toc_min_heading_level:2,toc_max_heading_level:3},P="Simulator",O={id:"particles/simulator",title:"Simulator",description:"The Simulator shader is in control of updating the data of all Particles, it allows their position and velocity to react to different forces in real time and can also re-spawn particles under certain conditions.",source:"@site/docs/particles/simulator.mdx",sourceDirName:"particles",slug:"/particles/simulator",permalink:"/QuantumDocs/docs/particles/simulator",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,toc_min_heading_level:2,toc_max_heading_level:3},sidebar:"docSidebar",previous:{title:"Troubleshooting & FAQ",permalink:"/QuantumDocs/docs/particles/troubleshooting"},next:{title:"Visualizer",permalink:"/QuantumDocs/docs/particles/visualizer"}},k={},N=[{value:"Base Settings",id:"base-settings",level:2},{value:"Input Texture",id:"input-texture",level:4},{value:"Simulator ID",id:"simulator-id",level:4},{value:"Simulator Count",id:"simulator-count",level:4},{value:"Simulation Speed",id:"simulation-speed",level:4},{value:"Simulation Scale",id:"simulation-scale",level:4},{value:"Speed Loss",id:"speed-loss",level:4},{value:"Speed Limit",id:"speed-limit",level:4},{value:"Forces",id:"forces",level:2},{value:"Affect",id:"affect",level:4},{value:"Field Strength",id:"field-strength",level:4},{value:"Field Behavior",id:"field-behavior",level:4},{value:"Strength Falloff",id:"strength-falloff",level:4},{value:"Distance Offset",id:"distance-offset",level:4},{value:"Force Limit",id:"force-limit",level:4},{value:"Force over Distance Graph",id:"force-over-distance-graph",level:4},{value:"Attraction",id:"attraction",level:3},{value:"Attraction Mode",id:"attraction-mode",level:4},{value:"Position",id:"position",level:4},{value:"Attraction Shape",id:"attraction-shape",level:4},{value:"Attraction Shape",id:"attraction-shape-1",level:4},{value:"Offset",id:"offset",level:4},{value:"Attraction Shape",id:"attraction-shape-2",level:4},{value:"Change Speed",id:"change-speed",level:4},{value:"Attraction Shape",id:"attraction-shape-3",level:4},{value:"Offset Texture",id:"offset-texture",level:4},{value:"Directional",id:"directional",level:3},{value:"Shape Mode",id:"shape-mode",level:4},{value:"Direction",id:"direction",level:4},{value:"Space",id:"space",level:4},{value:"Direction",id:"direction-1",level:4},{value:"Cone Width",id:"cone-width",level:4},{value:"Inward Strength",id:"inward-strength",level:4},{value:"Gradient Length",id:"gradient-length",level:4},{value:"Space",id:"space-1",level:4},{value:"Direction",id:"direction-2",level:4},{value:"Cone Width",id:"cone-width-1",level:4},{value:"Space",id:"space-2",level:4},{value:"Rotational",id:"rotational",level:3},{value:"Rotation Axis",id:"rotation-axis",level:4},{value:"Inwards Angle",id:"inwards-angle",level:4},{value:"Distance Factor",id:"distance-factor",level:4},{value:"Distance From",id:"distance-from",level:4},{value:"Space",id:"space-3",level:4},{value:"Turbulence",id:"turbulence",level:3},{value:"Density",id:"density",level:4},{value:"Panning",id:"panning",level:4},{value:"Time Dependent",id:"time-dependent",level:4},{value:"Change Speed",id:"change-speed-1",level:4},{value:"Space",id:"space-4",level:4},{value:"Drag",id:"drag",level:3},{value:"Drag Mode",id:"drag-mode",level:4},{value:"Particle Spawning",id:"particle-spawning",level:2},{value:"Data Sources",id:"data-sources",level:3},{value:"Shape Texture (<code>Single Texture</code> Mode)",id:"shape-texture-single-texture-mode",level:4},{value:"Position Source",id:"position-source",level:4},{value:"Position Texture",id:"position-texture",level:4},{value:"Position",id:"position-1",level:4},{value:"Start Position",id:"start-position",level:4},{value:"End Position",id:"end-position",level:4},{value:"Start Position",id:"start-position-1",level:4},{value:"End Position Simulator",id:"end-position-simulator",level:4},{value:"Radius",id:"radius",level:4},{value:"Position",id:"position-2",level:4},{value:"Rotation",id:"rotation",level:4},{value:"Scale",id:"scale",level:4},{value:"Position",id:"position-3",level:4},{value:"Rotation",id:"rotation-1",level:4},{value:"Scale",id:"scale-1",level:4},{value:"Velocity Source",id:"velocity-source",level:4},{value:"Velocity Texture",id:"velocity-texture",level:4},{value:"Velocity",id:"velocity",level:4},{value:"Rotation Space",id:"rotation-space",level:4},{value:"Min Velocity",id:"min-velocity",level:4},{value:"Max Velocity",id:"max-velocity",level:4},{value:"Separate Axes",id:"separate-axes",level:4},{value:"Rotation Space",id:"rotation-space-1",level:4},{value:"Speed",id:"speed",level:4},{value:"Speed",id:"speed-1",level:4},{value:"Central Distance Factor",id:"central-distance-factor",level:4},{value:"Starting Age Source",id:"starting-age-source",level:4},{value:"Starting Age Texture",id:"starting-age-texture",level:4},{value:"Starting Age",id:"starting-age",level:4},{value:"Min Starting Age",id:"min-starting-age",level:4},{value:"Max Starting Age",id:"max-starting-age",level:4},{value:"Lifetime Source",id:"lifetime-source",level:4},{value:"Lifetime Texture",id:"lifetime-texture",level:4},{value:"Lifetime",id:"lifetime",level:4},{value:"Min Lifetime",id:"min-lifetime",level:4},{value:"Max Lifetime",id:"max-lifetime",level:4},{value:"Particle Re-Spawn Check",id:"particle-re-spawn-check",level:4},{value:"Spawn Rate",id:"spawn-rate",level:4},{value:"Time Error Compensation",id:"time-error-compensation",level:4},{value:"Respawn Conditions",id:"respawn-conditions",level:3},{value:"Position Conditions",id:"position-conditions",level:4},{value:"Position Below",id:"position-below",level:4},{value:"Position Above",id:"position-above",level:4},{value:"Distance Below",id:"distance-below",level:4},{value:"Distance Above",id:"distance-above",level:4},{value:"Distance Below",id:"distance-below-1",level:4},{value:"Distance Above",id:"distance-above-1",level:4},{value:"Velocity Conditions",id:"velocity-conditions",level:4},{value:"Velocity Below",id:"velocity-below",level:4},{value:"Velocity Above",id:"velocity-above",level:4},{value:"Velocity Below",id:"velocity-below-1",level:4},{value:"Velocity Above",id:"velocity-above-1",level:4},{value:"Age Conditions",id:"age-conditions",level:4},{value:"Age Above Lifetime",id:"age-above-lifetime",level:4},{value:"Infinite Lifetime",id:"infinite-lifetime",level:4},{value:"Sampling Offset",id:"sampling-offset",level:4},{value:"Constant Offset",id:"constant-offset",level:4},{value:"Dynamic Offset",id:"dynamic-offset",level:4},{value:"Offset Texture",id:"offset-texture-1",level:4},{value:"Inherit Movement",id:"inherit-movement",level:4},{value:"Random Seed",id:"random-seed",level:4},{value:"Better Quality Noise",id:"better-quality-noise",level:4},{value:"Time Dependent Noise",id:"time-dependent-noise",level:4}];function R(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",p:"p",strong:"strong",...(0,l.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"simulator",children:"Simulator"})}),"\n",(0,n.jsx)(i.p,{children:"The Simulator shader is in control of updating the data of all Particles, it allows their position and velocity to react to different forces in real time and can also re-spawn particles under certain conditions."}),"\n",(0,n.jsx)(i.p,{children:"This shader has to be used on the two Simulator GameObjects in the Quantum Particles prefabs."}),"\n",(0,n.jsx)(i.p,{children:"If you want to change how the particles behave, interact, spawn or their movement patterns, this is the shader you will be working with."}),"\n",(0,n.jsx)(i.p,{children:"Currently, every setup has two materials with this shader, one for each hand, this has a technical reason as at least two unique simulators are required, working in tandem, to make the simulation work."}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"base-settings",children:"Base Settings"}),"\n",(0,n.jsx)(i.h4,{id:"input-texture",children:"Input Texture"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," containing the particle input data."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"DO NOT"})," remove this texture or edit the settings, unless you know what you are doing, without it the simulation will not work and the particles might not move or show up at all."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"EXCEPTION"}),": if you want to change the amount of particles, follow this guide: ",(0,n.jsx)(i.a,{href:"./setup-avatar#change-particle-amount",children:"Change Particle Amount"}),"."]}),"\n",(0,n.jsx)(i.h4,{id:"simulator-id",children:"Simulator ID"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Integer"})," containing the simulator ID, typically set to ",(0,n.jsx)(i.code,{children:"0"})," for the left hand and ",(0,n.jsx)(i.code,{children:"1"})," for the right hand."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"DO NOT"})," change this setting, unless you know what you are doing, otherwise the simulation will not work and the particles might not move or show up at all."]}),"\n",(0,n.jsx)(i.h4,{id:"simulator-count",children:"Simulator Count"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Integer"})," containing the number of simulators, typically set to ",(0,n.jsx)(i.code,{children:"2"})," for all current setups."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"DO NOT"})," change this setting, unless you know what you are doing, otherwise some features might break or will not work as intended."]}),"\n",(0,n.jsx)(i.h4,{id:"simulation-speed",children:"Simulation Speed"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," controlling the Speed of the simulation, typically set to ",(0,n.jsx)(i.code,{children:"1.0"})," for normal speed.\r\nThis value will be used as a multiplier for all time based calculations, this means you can change this value to slow down or speed up the simulation.\r\nTechnically negative values will also work, but might have unexpected results."]}),"\n",(0,n.jsx)(i.h4,{id:"simulation-scale",children:"Simulation Scale"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," controlling the Scale of the simulation, typically set to ",(0,n.jsx)(i.code,{children:"1.0"})," for normal scale.\r\nThis value will be used as a multiplier for all distance based calculations, this means you can scale up the simulation while keeping the same behavior for the particles.\r\nThis could be used to scale the particles with your avatar if you want the effects to look the same relative to your avatar's size.\r\nTechnically negative values will also work, but might have unexpected results."]}),"\n",(0,n.jsx)(i.h4,{id:"speed-loss",children:"Speed Loss"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 1.0]"}),", used to control how much of the velocity is approximately lost every second of the simulation.\r\nA value of ",(0,n.jsx)(i.code,{children:"1.0"})," means all speed will be lost over the span of a second, while a value of ",(0,n.jsx)(i.code,{children:"0.0"})," means that speed will never be lost over time, this can have wild effects when forces keep acting on a particle and keep speeding them up, so choose carefully.\r\nDue to varying precision with different frame rates this value can slightly fluctuate in different situations and hardware."]}),"\n",(0,n.jsx)(i.h4,{id:"speed-limit",children:"Speed Limit"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.001, 1000.0]"}),", used to control the maximum speed a particle can have.\r\nThis value is used to prevent particles from moving too fast and potentially breaking the simulation or flying out of range.\r\nAfter every simulation step the speed of a particle will be clamped to this value if it exceeds it, this will not affect the direction a particle can travel in, but particles traveling at the speed limit will react differently to forces."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"forces",children:"Forces"}),"\n",(0,n.jsx)(i.p,{children:"Forces are what makes the particles act dynamically, they can be used to simulate attraction, repulsion, gravity, wind, drag, turbulence and many more effects.\r\nAll forces can be toggled individually and have their own settings to control their strength and behavior."}),"\n",(0,n.jsx)(i.p,{children:"The following settings are present for all forces:"}),"\n",(0,n.jsx)(i.h4,{id:"affect",children:"Affect"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between a force affecting the ",(0,n.jsx)(i.code,{children:"Position"})," or the ",(0,n.jsx)(i.code,{children:"Velocity"})," of a particle.\r\nWhen a force is applied to the ",(0,n.jsx)(i.code,{children:"Position"})," of a particle it will always be moved exactly as the force direction and strength dictates and will stop moving if the strength is zero.\r\nWhen applied to the ",(0,n.jsx)(i.code,{children:"Velocity"})," of a particle it will keep accelerating towards the force direction while the strength is larger than zero and keeps moving even if the force is no longer present."]}),"\n",(0,n.jsxs)(i.p,{children:["Typically a force would act on the Velocity of a particle, but if the speed loss is too large they might not be able to move at all, in this case you could try to apply the force to the position instead.\r\nUse the ",(0,n.jsx)(i.code,{children:"Position"})," setting with caution if multiple particles will be moved to the same spot they might no longer separate afterwards."]}),"\n",(0,n.jsx)(i.h4,{id:"field-strength",children:"Field Strength"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[-100.0, 100.0]"}),", used as a basic multiplier for the force. Use this value if you want to for example make particles get attracted/repelled stronger/weaker."]}),"\n",(0,n.jsx)(i.h4,{id:"field-behavior",children:"Field Behavior"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between a ",(0,n.jsx)(i.code,{children:"Uniform"})," or ",(0,n.jsx)(i.code,{children:"Dynamic"})," force field.\r\nA ",(0,n.jsx)(i.code,{children:"Uniform"})," force field will have the same strength no matter the distance, while a ",(0,n.jsx)(i.code,{children:"Dynamic"})," force field will use the following parameters to have a different strength dependent on distance."]}),"\n",(0,n.jsxs)(i.p,{children:["The calculations for the ",(0,n.jsx)(i.code,{children:"Dynamic"})," force field are roughly as follows: ",(0,n.jsx)(i.code,{children:"clamp(pow(particleDistance + offset, falloff) * strength, -maxAttraction, maxAttraction)"})," and a graph showing the ",(0,n.jsx)(i.a,{href:"./simulator#force-over-distance-graph",children:"Force over Distance"})," can be seen at the end of the force field settings."]}),"\n",(0,n.jsx)(i.h4,{id:"strength-falloff",children:"Strength Falloff"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[-100.0, 100.0]"}),", used as an exponent for the distance based strength falloff.\r\nThis means that for positive values the force will get stronger the further away a particle is from the source, while for negative values the force will get weaker the further away a particle is from the source.\r\nA value of ",(0,n.jsx)(i.code,{children:"0.0"})," will result in a constant force field strength, which is basically the same as setting the ",(0,n.jsx)(i.a,{href:"./simulator#field-behavior",children:"Field Behavior"})," to ",(0,n.jsx)(i.code,{children:"Uniform"}),"."]}),"\n",(0,n.jsx)(i.h4,{id:"distance-offset",children:"Distance Offset"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value between ",(0,n.jsx)(i.code,{children:"0.0"})," and ",(0,n.jsx)(i.code,{children:"1.0"}),", used to offset the distance calculation for the force field.\r\nThis means that the force field will act as if the particles are further away from the source than they actually are.\r\nThis is mainly useful if you don't want the flipped field strength behavior for distances below ",(0,n.jsx)(i.code,{children:"1.0"}),"."]}),"\n",(0,n.jsx)(i.h4,{id:"force-limit",children:"Force Limit"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.001, 1000.0]"}),", used to limit the maximum strength a force can have.\r\nThis is ",(0,n.jsx)(i.strong,{children:"NOT"})," related or connected to the speed limit and will only affect the maximum effect this specific force can have on a particle."]}),"\n",(0,n.jsx)(i.h4,{id:"force-over-distance-graph",children:"Force over Distance Graph"}),"\n",(0,n.jsx)(i.p,{children:"This graph shows the strength of the force field over distance, the x-axis represents the distance from the source and the y-axis represents the strength of the force.\r\nBoth axes will scale dynamically to show the fully possible strength range of the force depending on the force limit."}),"\n",(0,n.jsx)(i.p,{children:"The red lines represent the current sample point, for which the values will be displayed at the top right of the graph (D=Distance, F=Force).\r\nBy double-clicking on the graph you can set a new sample point, which will update the red lines and corresponding values at the top right."}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"attraction",children:"Attraction"}),"\n",(0,n.jsx)(i.h4,{id:"attraction-mode",children:"Attraction Mode"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"ATTR_FORCE_POINT",label:"Point",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"position",children:"Position"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the position of the point to attract particles to.\r\nThis position is relative to the simulator GameObject and in local space."]}),"\n"]})}),(0,n.jsx)(A,{value:"ATTR_FORCE_SHAPE",label:"Shape",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"attraction-shape",children:"Attraction Shape"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," containing positions for each individual particle to be attracted to."]}),"\n"]})}),(0,n.jsx)(A,{value:"ATTR_FORCE_SHAPE_OFFSET",label:"Shape Offset",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"attraction-shape-1",children:"Attraction Shape"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," containing positions for each individual particle to be attracted to."]}),"\n",(0,n.jsx)(i.h4,{id:"offset",children:"Offset"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," used as an offset for indexing the positions in the shape texture. For example this can be used to attract particles to a different position in the same shape texture."]}),"\n"]})}),(0,n.jsx)(A,{value:"ATTR_FORCE_SHAPE_DYNAMIC_OFFSET",label:"Shape Dynamic Offset",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"attraction-shape-2",children:"Attraction Shape"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," containing positions for each individual particle to be attracted to."]}),"\n",(0,n.jsx)(i.h4,{id:"change-speed",children:"Change Speed"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," used as an offset over time for indexing the positions in the shape texture. Having a value of ",(0,n.jsx)(i.code,{children:"1.0"})," will make the particles be attracted to a different position every second."]}),"\n"]})}),(0,n.jsx)(A,{value:"ATTR_FORCE_SHAPE_INDIVIDUAL_OFFSET",label:"Shape Individual Offset",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"attraction-shape-3",children:"Attraction Shape"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," containing positions for each individual particle to be attracted to."]}),"\n",(0,n.jsx)(i.h4,{id:"offset-texture",children:"Offset Texture"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#offset-texture",children:(0,n.jsx)(i.code,{children:"Offset Texture"})})," containing individual offsets for each particle to be used for indexing the positions in the shape texture.\r\nThis can be used for example to make the particles follow each other in a very specific structure."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"directional",children:"Directional"}),"\n",(0,n.jsx)(i.h4,{id:"shape-mode",children:"Shape Mode"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"DIR_FORCE_SHAPE_UNIFORM",label:"Uniform",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"direction",children:"Direction"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the direction of the force.\r\nThe length of this vector is irrelevant, only the direction will be used, so a vector like ",(0,n.jsx)(i.code,{children:"(0.0, 1.0, 0.0)"})," will have the same effect as ",(0,n.jsx)(i.code,{children:"(0.0, 1000.0, 0.0)"}),"."]}),"\n",(0,n.jsx)(i.h4,{id:"space",children:"Space"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between ",(0,n.jsx)(i.code,{children:"World"})," and ",(0,n.jsx)(i.code,{children:"Local"})," space for the direction of the force.\r\nIn ",(0,n.jsx)(i.code,{children:"World"})," space the direction will be relative to the world, while in ",(0,n.jsx)(i.code,{children:"Local"})," space the direction will be relative to the simulator GameObject."]}),"\n"]})}),(0,n.jsx)(A,{value:"DIR_FORCE_SHAPE_FUNNEL",label:"Funnel",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"direction-1",children:"Direction"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the direction of the force.\r\nThe length of this vector is irrelevant, only the direction will be used, so a vector like ",(0,n.jsx)(i.code,{children:"(0.0, 1.0, 0.0)"})," will have the same effect as ",(0,n.jsx)(i.code,{children:"(0.0, 1000.0, 0.0)"}),"."]}),"\n",(0,n.jsx)(i.h4,{id:"cone-width",children:"Cone Width"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 100.0]"}),", used to control the width of the funnel cone.\r\nEvery particle outside of this cone will be attracted towards the center of the cone, while particles inside the cone will be moved in the direction of the cone."]}),"\n",(0,n.jsx)(i.h4,{id:"inward-strength",children:"Inward Strength"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 1.0]"}),", used to control how much the particles will be attracted towards the center of the cone rather than the direction of the cone."]}),"\n",(0,n.jsx)(i.h4,{id:"gradient-length",children:"Gradient Length"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0001, 100.0]"}),", used to control the length of the gradient from particles being attracted directly to the center of the cone to particles being attracted in the direction of the cone.\r\nThis value is measured from the surface of the cone outwards."]}),"\n",(0,n.jsx)(i.h4,{id:"space-1",children:"Space"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between ",(0,n.jsx)(i.code,{children:"World"})," and ",(0,n.jsx)(i.code,{children:"Local"})," space for the direction of the force.\r\nIn ",(0,n.jsx)(i.code,{children:"World"})," space the direction will be relative to the world, while in ",(0,n.jsx)(i.code,{children:"Local"})," space the direction will be relative to the simulator GameObject."]}),"\n"]})}),(0,n.jsx)(A,{value:"DIR_FORCE_SHAPE_COILGUN",label:"Coilgun",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"direction-2",children:"Direction"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the direction of the force.\r\nThe length of this vector is irrelevant, only the direction will be used, so a vector like ",(0,n.jsx)(i.code,{children:"(0.0, 1.0, 0.0)"})," will have the same effect as ",(0,n.jsx)(i.code,{children:"(0.0, 1000.0, 0.0)"}),"."]}),"\n",(0,n.jsx)(i.h4,{id:"cone-width-1",children:"Cone Width"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 100.0]"}),", used to control the width of the coilgun cone.\r\nParticles inside this cone will be moved in the direction of the coilgun, for particles outside of this cone the force depends on their position relative to the starting point of the coilgun.\r\nParticles in front of the coilgun will be brought back in a circle around the coilgun starting point, while particles behind the coilgun will be pushed towards the coilgun center."]}),"\n",(0,n.jsx)(i.h4,{id:"space-2",children:"Space"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between ",(0,n.jsx)(i.code,{children:"World"})," and ",(0,n.jsx)(i.code,{children:"Local"})," space for the direction of the force.\r\nIn ",(0,n.jsx)(i.code,{children:"World"})," space the direction will be relative to the world, while in ",(0,n.jsx)(i.code,{children:"Local"})," space the direction will be relative to the simulator GameObject."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"rotational",children:"Rotational"}),"\n",(0,n.jsx)(i.h4,{id:"rotation-axis",children:"Rotation Axis"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the axis of rotation for the force.\r\nThe length of this vector is irrelevant, only the direction will be used, so a vector like ",(0,n.jsx)(i.code,{children:"(0.0, 1.0, 0.0)"})," will have the same effect as ",(0,n.jsx)(i.code,{children:"(0.0, 1000.0, 0.0)"}),"."]}),"\n",(0,n.jsx)(i.h4,{id:"inwards-angle",children:"Inwards Angle"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[-1.0, 1.0]"}),", used to control the angle of rotation for the force.\r\nThis is ",(0,n.jsx)(i.strong,{children:"NOT"})," the angle of rotation, but instead controls how much the particles will be rotated towards the axis of rotation and the direction (clockwise for positive and counter-clockwise for negative values). A value of ",(0,n.jsx)(i.code,{children:"-1.0"})," or ",(0,n.jsx)(i.code,{children:"1.0"})," will rotate the particles fully towards the axis."]}),"\n",(0,n.jsx)(i.h4,{id:"distance-factor",children:"Distance Factor"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 1.0]"}),", used to determine how much the distance from the axis of rotation will affect the rotation.\r\nA value of ",(0,n.jsx)(i.code,{children:"0.0"})," will result in no distance based scaling, while a value of ",(0,n.jsx)(i.code,{children:"1.0"})," will have the distance multiplied with the rotation strength."]}),"\n",(0,n.jsx)(i.h4,{id:"distance-from",children:"Distance From"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between the ",(0,n.jsx)(i.code,{children:"Point"})," or the ",(0,n.jsx)(i.code,{children:"Axis"})," of rotation for the distance calculation.\r\nWhen set to ",(0,n.jsx)(i.code,{children:"Point"})," the distance will be calculated from the position of the simulator GameObject, while when set to ",(0,n.jsx)(i.code,{children:"Axis"})," the distance will be calculated from the axis of rotation."]}),"\n",(0,n.jsx)(i.h4,{id:"space-3",children:"Space"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between ",(0,n.jsx)(i.code,{children:"World"})," and ",(0,n.jsx)(i.code,{children:"Local"})," space for the direction of the force.\r\nIn ",(0,n.jsx)(i.code,{children:"World"})," space the direction will be relative to the world, while in ",(0,n.jsx)(i.code,{children:"Local"})," space the direction will be relative to the simulator GameObject."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"turbulence",children:"Turbulence"}),"\n",(0,n.jsx)(i.p,{children:"The Turbulence force can be used to create chaotic movement patterns for the particles and introduce some natural randomness to the simulation."}),"\n",(0,n.jsx)(i.h4,{id:"density",children:"Density"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the density of the turbulence.\r\nThis value controls how much the Turbulence will change over a given area, a higher value will result in more chaotic movement, while a lower value will result in more uniform movement."]}),"\n",(0,n.jsx)(i.h4,{id:"panning",children:"Panning"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the panning of the turbulence.\r\nThis value controls how and in what direction the Turbulence will move over time, a higher value will result in faster movement."]}),"\n",(0,n.jsx)(i.h4,{id:"time-dependent",children:"Time Dependent"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Checkbox"})," to toggle if the Turbulence should be time dependent.\r\nWhen enabled the Turbulence will change over time, while when disabled the Turbulence will be static."]}),"\n",(0,n.jsx)(i.h4,{id:"change-speed-1",children:"Change Speed"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," used to control how fast the Turbulence will change over time."]}),"\n",(0,n.jsx)(i.h4,{id:"space-4",children:"Space"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between ",(0,n.jsx)(i.code,{children:"World"})," and ",(0,n.jsx)(i.code,{children:"Local"})," space for the direction of the force.\r\nIn ",(0,n.jsx)(i.code,{children:"World"})," space the direction will be relative to the world, while in ",(0,n.jsx)(i.code,{children:"Local"})," space the direction will be relative to the simulator GameObject."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"drag",children:"Drag"}),"\n",(0,n.jsx)(i.p,{children:"The Drag force can be used to drag the particles around using the simulator GameObjects movement."}),"\n",(0,n.jsxs)(i.p,{children:["When combined with a ",(0,n.jsx)(i.code,{children:"Uniform"})," field of strength ",(0,n.jsx)(i.code,{children:"1.0"})," and both positional and rotational drag, this can be used ",(0,n.jsx)(i.strong,{children:"grab"})," and move particles around as if they were attached to the simulator GameObject."]}),"\n",(0,n.jsx)(i.h4,{id:"drag-mode",children:"Drag Mode"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"DRAG_FORCE_POSITION",label:"Position",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Only the positional change of the simulator GameObject will be used to drag the particles around."}),"\n"]})}),(0,n.jsx)(A,{value:"DRAG_FORCE_ROTATION",label:"Rotation",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Only the rotational change of the simulator GameObject will be used to drag the particles around."}),"\n"]})}),(0,n.jsx)(A,{value:"DRAG_FORCE_BOTH",label:"Both",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Both the positional and rotational change of the simulator GameObject will be used to drag the particles around."}),"\n"]})})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"particle-spawning",children:"Particle Spawning"}),"\n",(0,n.jsxs)(i.p,{children:['In the Particle Spawning section you can control how particles are spawned, this includes where they are spawned, how they move and how long they live.\r\nThe Quantum Particles system will always have a fixed amount of particles, so it would be more accurate to say that particles are re-spawned rather than spawned.\r\nEven after a particle "dies" it will still be part of the simulation, but might be invisible depending on the visualizer settings.\r\nThis is why in the following some values can be set to ',(0,n.jsx)(i.code,{children:"Keep"}),", which means that the value will be kept from the previous particle life cycle."]}),"\n",(0,n.jsx)(i.h3,{id:"data-sources",children:"Data Sources"}),"\n",(0,n.jsxs)(i.p,{children:["You can either use a ",(0,n.jsx)(i.code,{children:"Single Texture"})," for all particle data or use ",(0,n.jsx)(i.code,{children:"Multiple Sources"})," for different data types like position, velocity, age and life."]}),"\n",(0,n.jsxs)(i.h4,{id:"shape-texture-single-texture-mode",children:["Shape Texture (",(0,n.jsx)(i.code,{children:"Single Texture"})," Mode)"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," containing all the data for the particles to be spawned."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h4,{id:"position-source",children:"Position Source"}),"\n",(0,n.jsx)(i.p,{children:"All position sources are relative to the simulator GameObject and in local space, except for the Texture which can be toggled between local and world space."}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_POS_KEEP",label:"Keep",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Position will be kept from the previous particle life cycle."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_POS_TEX",label:"Texture",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"position-texture",children:"Position Texture"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," containing positions for each individual particle."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_POS_POINT",label:"Point",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"position-1",children:"Position"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the position to spawn particles at."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_POS_LINE",label:"Line",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"start-position",children:"Start Position"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the start position of the line to spawn particles on."]}),"\n",(0,n.jsx)(i.h4,{id:"end-position",children:"End Position"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the end position of the line to spawn particles on."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_POS_SIMLINE",label:"Sim Line",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"start-position-1",children:"Start Position"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the start position of the line to spawn particles on."]}),"\n",(0,n.jsx)(i.h4,{id:"end-position-simulator",children:"End Position Simulator"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Integer"})," containing the simulator ID of the simulator GameObject that will be used as the end position of the line to spawn particles on."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_POS_SPHERE",label:"Sphere",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"radius",children:"Radius"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the radius of the sphere to spawn particles in."]}),"\n",(0,n.jsx)(i.h4,{id:"position-2",children:"Position"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the position of the sphere to spawn particles in."]}),"\n",(0,n.jsx)(i.h4,{id:"rotation",children:"Rotation"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the rotation of the sphere to spawn particles in.\r\nA full rotation can be achieved by values from ",(0,n.jsx)(i.code,{children:"0.0"})," to ",(0,n.jsx)(i.code,{children:"1.0"})," for each axis."]}),"\n",(0,n.jsx)(i.h4,{id:"scale",children:"Scale"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the scale of the sphere to spawn particles in."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_POS_BOX",label:"Box",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"position-3",children:"Position"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the position of the sphere to spawn particles in."]}),"\n",(0,n.jsx)(i.h4,{id:"rotation-1",children:"Rotation"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the rotation of the sphere to spawn particles in.\r\nA full rotation can be achieved by values from ",(0,n.jsx)(i.code,{children:"0.0"})," to ",(0,n.jsx)(i.code,{children:"1.0"})," for each axis."]}),"\n",(0,n.jsx)(i.h4,{id:"scale-1",children:"Scale"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the scale of the sphere to spawn particles in."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h4,{id:"velocity-source",children:"Velocity Source"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_VEL_KEEP",label:"Keep",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Velocity will be kept from the previous particle life cycle."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_VEL_TEX",label:"Texture",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"velocity-texture",children:"Velocity Texture"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," containing velocities for each individual particle."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_VEL_VAL",label:"Value",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"velocity",children:"Velocity"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the velocity to spawn particles with."]}),"\n",(0,n.jsx)(i.h4,{id:"rotation-space",children:"Rotation Space"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between ",(0,n.jsx)(i.code,{children:"World"})," and ",(0,n.jsx)(i.code,{children:"Local"})," space for the velocity of the particles.\r\nIn ",(0,n.jsx)(i.code,{children:"World"})," space the velocity will be relative to the world, while in ",(0,n.jsx)(i.code,{children:"Local"})," space the velocity will be relative to the simulator GameObject."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_VEL_RANGE",label:"Range",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"min-velocity",children:"Min Velocity"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the minimum velocity to spawn particles with."]}),"\n",(0,n.jsx)(i.h4,{id:"max-velocity",children:"Max Velocity"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the maximum velocity to spawn particles with."]}),"\n",(0,n.jsx)(i.h4,{id:"separate-axes",children:"Separate Axes"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Checkbox"})," to toggle if the values for the velocity should be chosen for each axis separately.\r\nThis means that for example the X-axis can have it's minimum value while the Y-axis has it's maximum value."]}),"\n",(0,n.jsx)(i.h4,{id:"rotation-space-1",children:"Rotation Space"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Toggle"})," between ",(0,n.jsx)(i.code,{children:"World"})," and ",(0,n.jsx)(i.code,{children:"Local"})," space for the velocity of the particles.\r\nIn ",(0,n.jsx)(i.code,{children:"World"})," space the velocity will be relative to the world, while in ",(0,n.jsx)(i.code,{children:"Local"})," space the velocity will be relative to the simulator GameObject."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_VEL_SPHERE",label:"Sphere",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"speed",children:"Speed"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value giving the speed of the particles to spawn.\r\nThe direction of the velocity will be random and uniform on the surface of a sphere with the given speed.\r\nIf the distribution of the speed is not uniform enough you can enable the ",(0,n.jsx)(i.code,{children:"Better Quality Noise"})," setting."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_VEL_POSITION",label:"Position",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"speed-1",children:"Speed"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value giving the speed of the particles to spawn.\r\nThe direction of the velocity will be from the position of the simulator GameObject to the position of the particle."]}),"\n",(0,n.jsx)(i.h4,{id:"central-distance-factor",children:"Central Distance Factor"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value which will be multiplied with the distance from the simulator GameObject to the particle.\r\nThis can be used to control how much the speed will be affected by the distance.\r\nNegative values will result in the particles moving towards the simulator GameObject."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h4,{id:"starting-age-source",children:"Starting Age Source"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_AGE_KEEP",label:"Keep",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Age will be kept from the previous particle life cycle."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_AGE_TEX",label:"Texture",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"starting-age-texture",children:"Starting Age Texture"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," containing starting ages for each individual particle."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_AGE_VAL",label:"Value",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"starting-age",children:"Starting Age"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 1000.0]"})," giving the starting age of the particles."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_AGE_RANGE",label:"Range",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"min-starting-age",children:"Min Starting Age"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 1000.0]"})," giving the minimum starting age of the particles."]}),"\n",(0,n.jsx)(i.h4,{id:"max-starting-age",children:"Max Starting Age"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 1000.0]"})," giving the maximum starting age of the particles."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h4,{id:"lifetime-source",children:"Lifetime Source"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_LIFE_KEEP",label:"Keep",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Lifetime will be kept from the previous particle life cycle."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_LIFE_TEX",label:"Texture",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"lifetime-texture",children:"Lifetime Texture"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#render-texture",children:(0,n.jsx)(i.code,{children:"Render Texture"})})," or ",(0,n.jsx)(i.a,{href:"./textures#shape-texture",children:(0,n.jsx)(i.code,{children:"Shape Texture"})})," containing lifetimes for each individual particle."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_LIFE_VAL",label:"Value",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"lifetime",children:"Lifetime"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.001, 1000.0]"})," giving the lifetime of the particles."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_LIFE_RANGE",label:"Range",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"min-lifetime",children:"Min Lifetime"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.001, 1000.0]"})," giving the minimum lifetime of the particles."]}),"\n",(0,n.jsx)(i.h4,{id:"max-lifetime",children:"Max Lifetime"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.001, 1000.0]"})," giving the maximum lifetime of the particles."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h4,{id:"particle-re-spawn-check",children:"Particle Re-Spawn Check"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_RATE_ALL",label:"All",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"All particles will be checked every frame."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_RATE_PARTIAL",label:"Partial",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Only a fraction of the particles will be checked every frame."}),"\n",(0,n.jsx)(i.h4,{id:"spawn-rate",children:"Spawn Rate"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value giving the fraction of particles to be checked every second."]}),"\n",(0,n.jsx)(i.h4,{id:"time-error-compensation",children:"Time Error Compensation"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value in the ",(0,n.jsx)(i.strong,{children:"Range"})," ",(0,n.jsx)(i.code,{children:"[0.0, 1.0]"})," used to compensate for timing errors.\r\nThis value is used to compensate for the small fluctuations in frame rate and time passed between frames.\r\nA value of ",(0,n.jsx)(i.code,{children:"0.5"})," will result in 50% more particles being checked every second."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.h3,{id:"respawn-conditions",children:"Respawn Conditions"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_RESPAWN_ALWAYS",label:"Always",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Particles will always be re-spawned, no matter the state they are in."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_RESPAWN_CONDITIONS",label:"Conditions",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Particles will only be re-spawned if they meet the following conditions.\r\nEach type of data like position, velocity, age and lifetime can have a different condition to be met."}),"\n"]})})]}),"\n",(0,n.jsx)(i.h4,{id:"position-conditions",children:"Position Conditions"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_CONDITION_POS_OFF",label:"Off",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"The position of the particles will not be checked."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_CONDITION_POS_RANGE",label:"Range",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"position-below",children:"Position Below"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the position below which the particles will be re-spawned."]}),"\n",(0,n.jsx)(i.h4,{id:"position-above",children:"Position Above"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Vector3"})," containing the position above which the particles will be re-spawned."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_CONDITION_POS_DIST_SMALLER",label:"Distance Smaller",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"distance-below",children:"Distance Below"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the distance below which the particles will be re-spawned."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_CONDITION_POS_DIST_LARGER",label:"Distance Larger",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"distance-above",children:"Distance Above"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the distance above which the particles will be re-spawned."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_CONDITION_POS_DIST_RANGE",label:"Distance Range",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"distance-below-1",children:"Distance Below"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the distance below which the particles will be re-spawned."]}),"\n",(0,n.jsx)(i.h4,{id:"distance-above-1",children:"Distance Above"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the distance above which the particles will be re-spawned."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.h4,{id:"velocity-conditions",children:"Velocity Conditions"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_CONDITION_VEL_OFF",label:"Off",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"The velocity of the particles will not be checked."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_CONDITION_VEL_SMALLER",label:"Smaller",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"velocity-below",children:"Velocity Below"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the velocity below which the particles will be re-spawned."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_CONDITION_VEL_LARGER",label:"Larger",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"velocity-above",children:"Velocity Above"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the velocity above which the particles will be re-spawned."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_CONDITION_VEL_RANGE",label:"Range",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"velocity-below-1",children:"Velocity Below"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the velocity below which the particles will be re-spawned."]}),"\n",(0,n.jsx)(i.h4,{id:"velocity-above-1",children:"Velocity Above"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the velocity above which the particles will be re-spawned."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.h4,{id:"age-conditions",children:"Age Conditions"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_CONDITION_AGE_OFF",label:"Off",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"The age of the particles will not be checked."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_CONDITION_AGE_LARGER",label:"Larger",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"age-above-lifetime",children:"Age Above Lifetime"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used to control the age above which the particles will be re-spawned.\r\nThis value is relative to the lifetime of the particles, this means that a value of ",(0,n.jsx)(i.code,{children:"1.0"})," will be the full lifetime of the particles."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.h4,{id:"infinite-lifetime",children:"Infinite Lifetime"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Checkbox"})," to toggle if particles with an infinite lifetime should be re-spawned.\r\nThis might be necessary when particles have never been re-spawned before."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h4,{id:"sampling-offset",children:"Sampling Offset"}),"\n",(0,n.jsx)(i.p,{children:"This setting controls how the data for the particles is sampled from the input textures."}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_OFFSET_NONE",label:"None",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"No offset will be used for sampling the data."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_OFFSET_CONSTANT",label:"Constant",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"constant-offset",children:"Constant Offset"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used as an offset for sampling the data."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_OFFSET_DYNAMIC",label:"Dynamic",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"dynamic-offset",children:"Dynamic Offset"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value determining how fast the offset will change over time."]}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_OFFSET_INDIVIDUAL",label:"Individual",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.h4,{id:"offset-texture-1",children:"Offset Texture"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"./textures#offset-texture",children:(0,n.jsx)(i.code,{children:"Offset Texture"})})," containing individual offsets for each particle to be used for sampling the data."]}),"\n"]})})]}),"\n",(0,n.jsx)(i.h4,{id:"inherit-movement",children:"Inherit Movement"}),"\n",(0,n.jsxs)(y,{children:[(0,n.jsx)(A,{value:"SPAWN_ADD_NONE",label:"None",default:!0,children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Particles will not inherit any movement from the simulator GameObject."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_ADD_POSITION",label:"Position",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Particles will inherit the positional movement from the simulator GameObject."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_ADD_ROTATION",label:"Rotation",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Particles will inherit the rotational movement from the simulator GameObject."}),"\n"]})}),(0,n.jsx)(A,{value:"SPAWN_ADD_BOTH",label:"Both",children:(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Particles will inherit both the positional and rotational movement from the simulator GameObject."}),"\n"]})})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h4,{id:"random-seed",children:"Random Seed"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Float"})," value used as a seed for the random number generator.\r\nThis value will only affect the random number generator for the particle spawning."]}),"\n",(0,n.jsx)(i.h4,{id:"better-quality-noise",children:"Better Quality Noise"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Checkbox"})," to toggle if the noise used for the particle spawning should be of better quality.\r\nWhen enabled the noise will be of better quality, but will be slightly slower to calculate."]}),"\n",(0,n.jsx)(i.h4,{id:"time-dependent-noise",children:"Time Dependent Noise"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"Checkbox"})," to toggle if the noise used for the particle spawning should be time dependent.\r\nWhen enabled the noise will change over time, while when disabled the noise will stay the same."]})]})}function D(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(R,{...e})}):R(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>s});var n=t(6540);const l={},r=n.createContext(l);function o(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);